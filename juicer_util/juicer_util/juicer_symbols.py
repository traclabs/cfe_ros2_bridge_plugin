

# Class to hold an entry in the symbols table of the database generated by juicer.
class JuicerSymbolEntry():

    def __init__(self, node, my_id, elf, name, byte_size):
        self._node = node
        self._my_id = my_id
        self._elf = elf
        self._name = name
        self._byte_size = byte_size
        self._fields = []
        # flags indicating if this is a command or telemetry message
        self._is_command = False
        self._is_telemetry = False
        self._should_output = False
        self._nameMap = {
                "...*": "uint64",
                "CFE_ResourceId_t": "uint32",
                "CFE_ES_MemOffset_t": "uint32",
                "CFE_ES_MemAddress_t": "uint32",
                "CFE_ES_TaskId_t": "uint32",
                "CFE_ES_AppId_t": "uint32",
                "CFE_SB_PipeId_t": "uint32",
                "CFE_ES_MemHandle_t": "uint32",
                "CFE_ES_ExceptionAction_Enum_t": "uint8",
                "CFE_ES_TaskPriority_Atom_t": "uint16",
                "CFE_SB_MsgId_Atom_t": "uint32",
                "CFE_EVS_LogMode_Enum_t": "uint8",
                "CFE_EVS_MsgFormat_Enum_t": "uint8",
                "CFE_TIME_ClockState_Enum_t": "uint16",
                "CF_TransactionSeq_t": "uint32",
                "CF_UnionArgs_Payload": "uint32",
                "CF_EntityId_t": "uint32"
                }
        self._lowerCaseMap = {
                'char': 'string',
                'uint64...': 'uint64',
                'uint32...': 'uint32',
                'uint16...': 'uint16',
                'uint8...': 'uint8',
                'int64...': 'int64',
                'int32...': 'int32',
                'int16...': 'int16',
                'int8...': 'int8',
                'float': 'float32',
                'double': 'float64',
                'padding8': 'uint8',
                'padding16': 'uint16',
                'padding24': 'string',
                'padding32': 'uint32',
                'padding64': 'uint64',
                'padding...': 'char'
                }
        self._ros_name = self.generate_ros_name(self._name)
        if self._ros_name == "Bool":
            # not sure why other checks don't fix this
            self._ros_name = "bool"
        self._alternative = None

    def get_name(self):
        return self._name

    def set_name(self, new_name):
        self._name = new_name

    def get_ros_name(self):
        return self._ros_name

    def get_ros_name_array(self):
        array_name = self._ros_name + "[]"
        if self._ros_name.startswith("char"):
            array_name = "string"
        elif self._ros_name.startswith("string"):
            array_name = "string"
        return array_name

    def set_ros_name(self, name):
        self._ros_name = name

    def get_size(self):
        return self._byte_size

    def get_alternative(self):
        return self._alternative

    def set_alternative(self, altern):
        self._alternative = altern

    def get_ros_topic(self):
        n = self.get_name()
        n = n.replace("-", "_")
        n = n.replace(" ", "_")
        n = n.replace("__", "_")
        n = n.replace("*", "")
        return n.lower()

    def get_id(self):
        return self._my_id

    def add_field(self, field):
        if not field.get_ros_name():
            t = str(field.get_type())
            self._node.get_logger().debug("Skipping field " + field.get_name() + ", " + t)
        else:
            self._fields.append(field)
            self._fields.sort(key=field_byte_order)
            field_type = field.get_type_name()
            if "TelemetryHeader" in field_type:
                self._is_telemetry = True
            elif "CommandHeader" in field_type:
                self._is_command = True

    def get_fields(self):
        return self._fields

    def get_is_command(self):
        return self._is_command

    def get_is_telemetry(self):
        return self._is_telemetry

    def get_should_output(self):
        return self._should_output

    def set_should_output(self, output):
        self._should_output = output


    def generate_ros_name(self, symbol_name):
        n = symbol_name

        for key in self._nameMap:
            value = self._nameMap[key]
            if key.startswith("..."):
                newkey = key.replace("...","")
                if symbol_name.endswith(newkey):
                    n = value
                    break
            elif key.endswith("..."):
                newkey = key.replace("...","")
                if symbol_name.startswith(newkey):
                    n = value
                    break
            elif symbol_name == key:
                n = value
                break

        n = n.replace("_", "")
        n = n.replace(" ", "")
        n = n.replace("*", "")

        if n[0].islower():
            n = self.handle_lower_case_name(n)

        return n


    def handle_lower_case_name(self, lc_name):
        n = None
        for key in self._lowerCaseMap:
            value = self._lowerCaseMap[key]
            if key.startswith("..."):
                newkey = key.replace("...","")
                if lc_name.endswith(newkey):
                    n = value
                    break
            elif key.endswith("..."):
                newkey = key.replace("...","")
                if lc_name.startswith(newkey):
                    n = value
                    break
            elif lc_name == key:
                n = value
                break
        if n == None:
            n = lc_name.capitalize()

        return n


def field_byte_order(field):
    return field.get_byte_offset()
