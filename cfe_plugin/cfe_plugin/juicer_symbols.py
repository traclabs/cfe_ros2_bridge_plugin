#!/usr/bin/env python3

# Class to hold an entry in the symbols table of the database generated by juicer.
class JuicerSymbolEntry():

    def __init__(self, myid, elf, name, byte_size):
        self.myid = myid
        self.elf = elf
        self.name = name
        self.byte_size = byte_size
        self.fields = []
        # flags indicating if this is a command or telemetry message
        self.isCommand = False
        self.isTelemetry = False
        self.shouldOutput = False
        self.rosName = generateROSName(self.name)
        if self.rosName == "Bool":
            # not sure why other checks don't fix this
            self.rosName = "bool"
        self.alternative = None

    def getName(self):
        return self.name

    def getROSName(self):
        return self.rosName

    def getSize(self):
        return self.byte_size

    def getAlternative(self):
        return self.alternative

    def setAlternative(self, altern):
        self.alternative = altern

    def getROSTopic(self):
        n = self.getName()
        n = n.replace("-", "_")
        n = n.replace(" ", "_")
        n = n.replace("__", "_")
        n = n.replace("*", "")
        return n.lower()

    def getId(self):
        return self.myid

    def addField(self, field):
        if not field.getROSName():
            print("Skipping field " + field.getName() + " of type " + str(field.getType()))
        else:
            self.fields.append(field)
            fieldtype = field.getTypeName()
            if "TelemetryHeader" in fieldtype:
                self.isTelemetry = True
            elif "CommandHeader" in fieldtype:
                self.isCommand = True

    def getFields(self):
        return self.fields

    def getIsCommand(self):
        return self.isCommand

    def getIsTelemetry(self):
        return self.isTelemetry

    def getShouldOutput(self):
        return self.shouldOutput

    def setShouldOutput(self, output):
        self.shouldOutput = output

def generateROSName(symbolName):
    n = symbolName
    if n.endswith('*'):
        # indicates a pointer of size 8 bytes
        n = 'uint64'
    elif symbolName == "CFE_ResourceId_t":
        n = 'uint32'
    elif symbolName == "CFE_ES_MemOffset_t":
        n = 'uint32'
    elif symbolName == "CFE_ES_MemAddress_t":
        n = 'uint32'
    elif symbolName == "CFE_ES_TaskId_t":
        n = 'uint32'
    elif symbolName == "CFE_ES_AppId_t":
        n = 'uint32'
    elif symbolName == "CFE_SB_PipeId_t":
        n = 'uint32'
    elif symbolName == "CFE_ES_MemHandle_t":
        # not sure what this should be, but this is correct size
        n = 'uint32'
    elif symbolName == "CFE_ES_ExceptionAction_Enum_t":
        # not sure what this should be, but this is correct size
        n = 'uint8'
    elif symbolName == "CFE_ES_TaskPriority_Atom_t":
        # not sure what this should be, but this is correct size
        n = 'uint16'
    elif symbolName == "CFE_SB_MsgId_Atom_t":
        # not sure what this should be, but this is correct size
        n = 'uint32'
    elif symbolName == "CFE_EVS_LogMode_Enum_t":
        # not sure what this should be, but this is correct size
        n = 'uint8'
    elif symbolName == "CFE_EVS_MsgFormat_Enum_t":
        # not sure what this should be, but this is correct size
        n = 'uint8'
    elif symbolName == "CFE_TIME_ClockState_Enum_t":
        # not sure what this should be, but this is correct size
        n = 'uint16'
    n = n.replace("_", "")
    n = n.replace(" ", "")
    n = n.replace("*", "")

    if n[0].islower():
        n = handleLowerCaseName(n, symbolName)

    return n

def handleLowerCaseName(lcName, symbolName):
    n = lcName
    # map simple types to ROS2 types
    if n == 'char': # indicates a char array, so make it a string
        n = 'string'
    elif n.startswith('uint64'):
        n = 'uint64'
    elif n.startswith('uint32'):
        n = 'uint32'
    elif n.startswith('uint16'):
        n = 'uint16'
    elif n.startswith('uint8'):
        n = 'uint8'
    elif n.startswith('int64'):
        n = 'int64'
    elif n.startswith('int32'):
        n = 'int32'
    elif n.startswith('int16'):
        n = 'int16'
    elif n == 'padding8':
        n = 'uint8'
    elif n == 'padding16':
        n = 'uint16'
    elif n == 'padding32':
        n = 'uint32'
    elif n == 'padding64':
        n = 'uint64'
    elif n.startswith('padding'):
        # how to handle this?
        #print("Setting " + n + " to char")
        n = 'char'
    else:
        n = n.capitalize()
        #print("Capitalized " + n)
    return n
